<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LOFT French Konfigurator</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.155.0/build/three.module.js",
                "OrbitControls": "https://unpkg.com/three@0.155.0/examples/jsm/controls/OrbitControls.js",
                "dat.gui": "https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.module.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
// Importiere Three.js und dat.GUI
import * as THREE from 'three';
import { GUI } from 'dat.gui';
import { OrbitControls } from 'OrbitControls';

// Szene, Kamera und Renderer erstellen
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xd3d3d3); // Hintergrund auf hellgrau setzen

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Kamera-Steuerung hinzufügen
const controls = new OrbitControls(camera, renderer.domElement);

// Umrechnungsfaktor von Metern zu Zentimetern
const cm = 100;

// Boden erstellen
const floorGeometry = new THREE.PlaneGeometry(2000, 2000); // 20m x 20m in cm
const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Hellbraune Farbe für den Boden
const floor = new THREE.Mesh(floorGeometry, floorMaterial);
floor.rotation.x = -Math.PI / 2;
floor.position.y = 0; // Position des Bodens am Anfang der Wand
scene.add(floor);

// Wand mit Ausschnitt erstellen
const wallWidth = 1000; // 10m in cm
const wallHeight = 500; // 5m in cm
const wallThickness = 20; // 20cm

// Verwenden von Shape für die Wand mit einem Ausschnitt
const wallShape = new THREE.Shape();
wallShape.moveTo(-wallWidth / 2, 0);
wallShape.lineTo(wallWidth / 2, 0);
wallShape.lineTo(wallWidth / 2, wallHeight);
wallShape.lineTo(-wallWidth / 2, wallHeight);
wallShape.lineTo(-wallWidth / 2, 0);

// Ausschnitt für den Durchgang hinzufügen
const doorwayWidth = 200; // 2m in cm
const doorwayHeight = 300; // 3m in cm
const doorwayX = 0; // Mittig in der Wand
const doorwayY = 0; // Startet am Boden

const doorwayShape = new THREE.Path();
doorwayShape.moveTo(doorwayX - doorwayWidth / 2, doorwayY);
doorwayShape.lineTo(doorwayX + doorwayWidth / 2, doorwayY);
doorwayShape.lineTo(doorwayX + doorwayWidth / 2, doorwayY + doorwayHeight);
doorwayShape.lineTo(doorwayX - doorwayWidth / 2, doorwayY + doorwayHeight);
doorwayShape.lineTo(doorwayX - doorwayWidth / 2, doorwayY);
wallShape.holes.push(doorwayShape);

const wallGeometry = new THREE.ExtrudeGeometry(wallShape, { depth: wallThickness, bevelEnabled: false });
const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
const wall = new THREE.Mesh(wallGeometry, wallMaterial);
wall.position.z = -wallThickness / 2;
scene.add(wall);

// Licht hinzufügen
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);
const pointLight = new THREE.PointLight(0xffffff, 1);
pointLight.position.set(1000, 1000, 1000); // 10m x 10m x 10m in cm
scene.add(pointLight);

// Position der Kamera
camera.position.set(0, 500, 1500); // 5m hoch und 15m entfernt in cm

// GUI-Konfiguration
const gui = new GUI();
const options = {
  doorwayWidth: 200, // Initialwert 2m in cm
  doorwayHeight: 300, // Initialwert 3m in cm
  wallColor: '#ffffff'
};

gui.add(options, 'doorwayWidth', 100, 500).onChange((value) => {
  const newWallShape = new THREE.Shape();
  newWallShape.moveTo(-wallWidth / 2, 0);
  newWallShape.lineTo(wallWidth / 2, 0);
  newWallShape.lineTo(wallWidth / 2, wallHeight);
  newWallShape.lineTo(-wallWidth / 2, wallHeight);
  newWallShape.lineTo(-wallWidth / 2, 0);

  const newDoorwayShape = new THREE.Path();
  newDoorwayShape.moveTo(doorwayX - value / 2, doorwayY);
  newDoorwayShape.lineTo(doorwayX + value / 2, doorwayY);
  newDoorwayShape.lineTo(doorwayX + value / 2, doorwayY + doorwayHeight);
  newDoorwayShape.lineTo(doorwayX - value / 2, doorwayY + doorwayHeight);
  newDoorwayShape.lineTo(doorwayX - value / 2, doorwayY);
  newWallShape.holes.push(newDoorwayShape);

  wall.geometry.dispose();
  wall.geometry = new THREE.ExtrudeGeometry(newWallShape, { depth: wallThickness, bevelEnabled: false });
});

gui.add(options, 'doorwayHeight', 200, 500).onChange((value) => {
  const newWallShape = new THREE.Shape();
  newWallShape.moveTo(-wallWidth / 2, 0);
  newWallShape.lineTo(wallWidth / 2, 0);
  newWallShape.lineTo(wallWidth / 2, wallHeight);
  newWallShape.lineTo(-wallWidth / 2, wallHeight);
  newWallShape.lineTo(-wallWidth / 2, 0);

  const newDoorwayShape = new THREE.Path();
  newDoorwayShape.moveTo(doorwayX - doorwayWidth / 2, doorwayY);
  newDoorwayShape.lineTo(doorwayX + doorwayWidth / 2, doorwayY);
  newDoorwayShape.lineTo(doorwayX + doorwayWidth / 2, doorwayY + value);
  newDoorwayShape.lineTo(doorwayX - doorwayWidth / 2, doorwayY + value);
  newDoorwayShape.lineTo(doorwayX - doorwayWidth / 2, doorwayY);
  newWallShape.holes.push(newDoorwayShape);

  wall.geometry.dispose();
  wall.geometry = new THREE.ExtrudeGeometry(newWallShape, { depth: wallThickness, bevelEnabled: false });
});

gui.addColor(options, 'wallColor').onChange((value) => {
  wallMaterial.color.set(value);
});

// Animation-Schleife
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}

animate();
        
    </script>
</body>
</html>
